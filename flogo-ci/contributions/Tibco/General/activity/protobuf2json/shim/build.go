package main

import (
	"encoding/base64"
	"encoding/json"
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"os/exec"
	"path"
	"path/filepath"
	"strings"
	"text/template"
	"time"

	"github.com/project-flogo/flow/definition"
)

// Constants
var (
	ACTIVITYREF = "github.com/tibco/flogo-general/src/app/General/activity/protobuf2json"
	PACKAGE     = "protobuf2json"
)

// FlogoApp ...
type FlogoApp struct {
	Imports   []string    `json:"imports,omitempty"`
	Resources []*resource `json:"resources"`
}

type resource struct {
	ID   string                    `json:"id"`
	Data *definition.DefinitionRep `json:"data"`
}

// ProtoLocat ...
type ProtoLocat struct {
	protoFileName string
	flowName      string
	activityName  string
	content       []byte
}

// GetLocation ...
func (p *ProtoLocat) GetLocation() string {
	return filepath.Join(strings.ToLower(p.flowName), strings.ToLower(p.activityName))
}

// GetPackage ...
func (p *ProtoLocat) GetPackage() string {
	return filepath.ToSlash(filepath.Join("engine", p.flowName, p.activityName))
}

// GetRef ...
func (f *FlogoApp) GetRef(refAlias string) string {
	for _, ref := range f.Imports {
		if len(ref) > 0 {
			ref = strings.TrimSpace(ref)
			var alias string
			//var version string

			if strings.Index(ref, " ") > 0 {
				alias = strings.TrimSpace(ref[:strings.Index(ref, " ")])
				ref = strings.TrimSpace(ref[strings.Index(ref, " ")+1:])
			}

			if strings.Index(ref, "@") > 0 {
				//version = ref[strings.Index(ref, "@")+1:]
				ref = ref[:strings.Index(ref, "@")]
			}

			if len(alias) <= 0 {
				alias = filepath.Base(ref)
			}

			if refAlias == alias {
				return ref
			}
		}
	}
	return refAlias
}

type templateData struct {
	Timestamp time.Time
	Package   string
	Data      map[string][]byte
}

var mapMDTemplate = `// This file is autogenerated by mashling mapMDTemplate in build.go at {{ .Timestamp }}
package {{.Package}}

func init() {
	mapDSBytes = make(map[string][]byte)
	{{- range $key, $val := .Data}}
	mapDSBytes["{{$key}}"] = []byte{
		{{- range $b := $val}}{{$b}}, 
		{{- end}}
	}
	{{- end}}
}
`

func main() {
	flag.Parse()
	fmt.Println("Running build...")

	appPath, _ := os.Getwd()
	flogoJSONPath := filepath.Join(appPath, "..", "flogo.json")
	_, fileErr := os.Stat(flogoJSONPath)
	if fileErr != nil {
		// look in parent directory
		flogoJSONPath = filepath.Join(appPath, "..", "..", "flogo.json")
		_, err := os.Stat(flogoJSONPath)
		if err != nil {
			log.Println(fmt.Errorf("Cannot find flogo.json file: %s", err.Error()))
		}
	}

	log.Printf("appPath has been set to: %s\n", appPath)
	mapProtoContent, err := ReadAllProtoContent(flogoJSONPath)
	if err != nil {
		log.Println(fmt.Errorf("Ger proto file error: %s", err.Error()))
		return
	}
	mapDSBytes, err := GetAllDescriptorSetBytes(appPath, mapProtoContent)
	if err != nil {
		panic(err)
	}
	tData := templateData{
		Timestamp: time.Now(),
		Package:   PACKAGE,
		Data:      mapDSBytes,
	}
	err = generateSupportFile(appPath, tData)
	if err != nil {
		panic(err)
	}
	// cleanup build.go, shim_support.go and <fileName>.proto
	os.Remove(filepath.Join(appPath, "build.go"))
	log.Println("Completed build!")
}

// ReadAllProtoContent reads proto file contents from app json
func ReadAllProtoContent(flogoJSONPath string) (map[string]*ProtoLocat, error) {
	v, err := ioutil.ReadFile(flogoJSONPath)
	if err != nil {
		return nil, err
	}

	app := &FlogoApp{}
	err = json.Unmarshal(v, app)
	if err != nil {
		return nil, err
	}

	protoMap := make(map[string]*ProtoLocat)

	for _, v := range app.Resources {
		//Tasks
		var protoContent []byte
		for _, act := range v.Data.Tasks {
			if strings.HasPrefix(act.ActivityCfgRep.Ref, "#") {
				if app.GetRef(act.ActivityCfgRep.Ref[1:]) == ACTIVITYREF {
					//Get protco file
					loc := &ProtoLocat{flowName: strings.ToLower(v.Data.Name), activityName: strings.ToLower(act.Name)}
					if protoF, okk := act.ActivityCfgRep.Settings["protoFile"].(map[string]interface{}); okk {
						// file picker
						loc.protoFileName = protoF["filename"].(string)
						// decode protoFile content
						protoContentValue := protoF["content"].(string)
						index := strings.IndexAny(protoContentValue, ",")
						if index > -1 {
							protoContent, _ = base64.StdEncoding.DecodeString(protoContentValue[index+1:])
						} else {
							panic("Error in proto content")
						}
						loc.content = protoContent
						protoMap[loc.GetLocation()] = loc
					} else {
						panic("protoFile is not a map[string]interface{}")
					}
				}
			}
		}

		//Error Handlers
		//Tasks
		if v.Data.ErrorHandler != nil {
			for _, act := range v.Data.ErrorHandler.Tasks {
				if strings.HasPrefix(act.ActivityCfgRep.Ref, "#") {
					if app.GetRef(act.ActivityCfgRep.Ref[1:]) == ACTIVITYREF {
						//Get protco file
						loc := &ProtoLocat{flowName: strings.ToLower(v.Data.Name), activityName: strings.ToLower(act.Name)}
						if protoF, okk := act.ActivityCfgRep.Settings["protoFile"].(map[string]interface{}); okk {
							// file picker
							loc.protoFileName = protoF["filename"].(string)
							// decode protoFile content
							protoContentValue := protoF["content"].(string)
							index := strings.IndexAny(protoContentValue, ",")
							if index > -1 {
								protoContent, _ = base64.StdEncoding.DecodeString(protoContentValue[index+1:])
							} else {
								panic("Error in proto content")
							}
							loc.content = protoContent
							protoMap[loc.GetLocation()] = loc
						} else {
							// text box
							loc.protoFileName = act.ActivityCfgRep.Settings["protoName"].(string) + ".proto"
							loc.content = []byte(act.ActivityCfgRep.Settings["protoFile"].(string))
							protoMap[loc.GetLocation()] = loc
						}
					}
				}
			}
		}
	}
	return protoMap, nil
}

// GetAllDescriptorSetBytes converts proto content to descriptor set
func GetAllDescriptorSetBytes(appPath string, mapProtoContent map[string]*ProtoLocat) (map[string][]byte, error) {
	_, err := exec.LookPath("protoc")
	if err != nil {
		return nil, fmt.Errorf("Protoc is not available: %s", err.Error())
	}
	mapDSBytes := make(map[string][]byte)

	for key, protoLocat := range mapProtoContent {
		dir2Generate := filepath.Join(appPath, key)
		if _, err := os.Stat(dir2Generate); os.IsNotExist(err) {
			os.MkdirAll(dir2Generate, 0775)
		}
		fileName := filepath.Join(dir2Generate, protoLocat.protoFileName)
		err = ioutil.WriteFile(fileName, []byte(protoLocat.content), 0644)
		if err != nil {
			return mapDSBytes, err
		}
		mapDSBytes[key], err = getMDBytesFromProto(dir2Generate, protoLocat.protoFileName)
		if err != nil {
			return mapDSBytes, err
		}
	}
	return mapDSBytes, nil
}

func getMDBytesFromProto(srcDir string, protoFileName string) ([]byte, error) {
	tmpFile := protoFileName + "-tmp.pb"
	cmd := exec.Command("protoc",
		"--include_imports",
		"--descriptor_set_out="+tmpFile,
		"-I="+srcDir,
		path.Join(srcDir, protoFileName))
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	err := cmd.Run()
	if err != nil {
		fmt.Printf("Error creating pb files: %v\n", err)
		return nil, err
	}
	defer os.Remove(tmpFile)
	marshalledDescriptorSet, err := ioutil.ReadFile(tmpFile)
	if err != nil {
		return nil, err
	}
	return marshalledDescriptorSet, nil
}

func generateSupportFile(appPath string, tData templateData) error {
	t := template.Must(template.New("mapMDTemplate").Parse(mapMDTemplate))
	outFilePath := filepath.Join(appPath, "..", ACTIVITYREF, "mapmd.go")
	outFile, err := os.Create(outFilePath)
	if err != nil {
		log.Fatal("Unable to create mapmd.go: ", err)
		return err
	}
	defer outFile.Close()
	err = t.Execute(outFile, tData)
	if err != nil {
		return err
	}
	return nil
}
